# These functions transform a stream into detectors which fire when the recent window
# (default length is 15 minutes) is very different from the same period timeshifted by some
# unit (default shift is 1 week).
#
# The basic toggles are:
#   the length of windows to compare (by default, 15 minutes),
#   the space between windows (by default, 1 week, corresponding to week-over-week comparison),
#   the number of historical windows used to establish a baseline (by default, 4),
#   whether to exclude historical outliers when computing the baseline (i.e., whether to use
#       median or mean of the historical bands, default is to exclude),
#   whether to construct historical bands using growth rate or standard deviations,
#   and the orientation (above, below, or out-of-band).
#
# By default the firing and clearing thresholds are different (to reduce flappiness).
#
# These detectors are appropriate for signals with periodic behavior. The period enters via
# the space_between_windows argument.
#
# @author joe


def detector_helper(summary, fire_bot, clear_bot, clear_top, fire_top, orientation, annotations, event_annotations=None):
    if orientation == 'above':
        return detect(when(summary > fire_top), when(summary < clear_top), annotations=annotations, event_annotations=event_annotations)
    elif orientation == 'below':
        return detect(when(summary < fire_bot), when(summary > clear_bot), annotations=annotations, event_annotations=event_annotations)
    elif orientation == 'out_of_band':
        return detect(when(summary > fire_top or summary < fire_bot),
                      when(summary < clear_top and summary > clear_bot), mode='split', annotations=annotations, event_annotations=event_annotations)


def n_period_summary(stream, window_to_compare, space_between_windows, num_stddev,
                     num_periods, discard_historical_outliers=True):
    def f(x):
        return stream.timeshift(x * duration(space_between_windows)).mean_plus_stddev(
            stddevs=num_stddev,
            over=duration(window_to_compare))

    if discard_historical_outliers:
        if num_periods == 3:
            return median(f(1), f(2), f(3))
        elif num_periods == 4:
            return median(f(1), f(2), f(3), f(4))
        elif num_periods == 5:
            return median(f(1), f(2), f(3), f(4), f(5))
        elif num_periods == 6:
            return median(f(1), f(2), f(3), f(4), f(5), f(6))
        elif num_periods == 7:
            return median(f(1), f(2), f(3), f(4), f(5), f(6), f(7))
        elif num_periods >= 8:
            return median(f(1), f(2), f(3), f(4), f(5), f(6), f(7), f(8))
    else:
        if num_periods == 3:
            return mean(f(1), f(2), f(3))
        elif num_periods == 4:
            return mean(f(1), f(2), f(3), f(4))
        elif num_periods == 5:
            return mean(f(1), f(2), f(3), f(4), f(5))
        elif num_periods == 6:
            return mean(f(1), f(2), f(3), f(4), f(5), f(6))
        elif num_periods == 7:
            return mean(f(1), f(2), f(3), f(4), f(5), f(6), f(7))
        elif num_periods >= 8:
            return mean(f(1), f(2), f(3), f(4), f(5), f(6), f(7), f(8))


def period_summaries(stream, window_to_compare=duration('15m'),
                     space_between_windows=duration('1w'),
                     num_windows=4, num_stddev=0, discard_historical_outliers=True):
    space_between_windows_dur = duration(space_between_windows)
    window_to_compare_dur = duration(window_to_compare)
    if num_windows == 1:
        return stream.timeshift(space_between_windows_dur).mean_plus_stddev(stddevs=num_stddev,
                                                                            over=window_to_compare_dur)
    elif num_windows == 2:
        return mean(stream.timeshift(space_between_windows_dur).mean_plus_stddev(stddevs=num_stddev,
                                                                                 over=window_to_compare_dur),
                    stream.timeshift(2 * space_between_windows_dur).mean_plus_stddev(
                        stddevs=num_stddev,
                        over=window_to_compare_dur))
    elif num_windows >= 3:
        return n_period_summary(stream, window_to_compare_dur, space_between_windows_dur,
                                num_stddev,
                                num_windows,
                                discard_historical_outliers=discard_historical_outliers)



def detector_growth_rate(stream, window_to_compare=duration('15m'),
                         space_between_windows=duration('1w'),
                         num_windows=4, fire_growth_rate_threshold=0.2,
                         clear_growth_rate_threshold=0.1,
                         discard_historical_outliers=True, orientation='above'):
    space_between_windows_dur = duration(space_between_windows)
    window_to_compare_dur = duration(window_to_compare)
    assert fire_growth_rate_threshold >= clear_growth_rate_threshold, {'fire_growth_rate_threshold' : fire_growth_rate_threshold,
       'clear_growth_rate_threshold' : clear_growth_rate_threshold,
       'sfui_errorKeys' : ['fire_growth_rate_threshold', 'clear_growth_rate_threshold'],
       'sfui_errorTemplate': "change {{fire_growth_rate_threshold}} to a value greater than or equal to {{clear_growth_rate_threshold}} (or change {{clear_growth_rate_threshold}})"}
    assert space_between_windows_dur >= window_to_compare_dur, {'space_between_windows' : space_between_windows_dur,
       'window_to_compare' : window_to_compare_dur,
       'sfui_errorKeys' : ['space_between_windows', 'window_to_compare'],
       'sfui_errorTemplate': "change {{space_between_windows}} to a duration longer than or equal to {{window_to_compare}} (or change {{window_to_compare}})"}
    previous = period_summaries(stream, window_to_compare=window_to_compare_dur,
                                space_between_windows=space_between_windows_dur,
                                num_windows=num_windows, num_stddev=0,
                                discard_historical_outliers=discard_historical_outliers)
    summary = stream.mean(over=window_to_compare_dur)
    fb = (1 - fire_growth_rate_threshold) * previous
    cb = (1 - clear_growth_rate_threshold) * previous
    ct = (1 + clear_growth_rate_threshold) * previous
    ft = (1 + fire_growth_rate_threshold) * previous
    annotations = [annotate(summary, 'rolling mean', {'sfui_streamType': 'signal'}),
                   annotate(fb, 'lower fire threshold', {'sfui_streamType': 'threshold',
                                                         'sfui_state':'fire',
                                                         'sfui_orientation':'below',
                                                         'sfui_trigger':'outside',
                                                         'influencedBy': 'fire_growth_rate_threshold'}),
                   annotate(ft, 'upper fire threshold', {'sfui_streamType': 'threshold',
                                                         'sfui_state':'fire',
                                                         'sfui_orientation':'above',
                                                         'sfui_trigger':'outside' ,
                                                         'influencedBy': 'fire_growth_rate_threshold'}),
                   annotate(cb, 'lower clear threshold',
                            {'sfui_streamType': 'threshold',
                             'sfui_state':'clear',
                             'sfui_orientation':'below',
                             'sfui_trigger':'outside' ,
                             'influencedBy': 'clear_growth_rate_threshold'}),
                   annotate(ct, 'upper clear threshold',
                            {'sfui_streamType': 'threshold',
                             'sfui_state':'clear',
                             'sfui_orientation':'above',
                             'sfui_trigger':'outside' ,
                             'influencedBy': 'clear_growth_rate_threshold'})]
    event_annotations = {'current_window': str(window_to_compare_dur)}
    return detector_helper(summary, fb, cb, ct, ft, orientation, annotations, event_annotations)


def detector_mean_std(stream, window_to_compare=duration('15m'),
                      space_between_windows=duration('1w'),
                      num_windows=4, fire_num_stddev=3, clear_num_stddev=2.5,
                      discard_historical_outliers=True, orientation='above'):
    space_between_windows_dur = duration(space_between_windows)
    window_to_compare_dur = duration(window_to_compare)
    assert fire_num_stddev >= clear_num_stddev, {'fire_num_stddev' : fire_num_stddev, 'clear_num_stddev' : clear_num_stddev,
       'sfui_errorKeys' : ['fire_num_stddev', 'clear_num_stddev'],
       'sfui_errorTemplate': "change {{fire_num_stddev}} to a value greater than or equal to {{clear_num_stddev}} (or change {{clear_num_stddev}})"}
    assert space_between_windows_dur >= window_to_compare_dur, {'space_between_windows' : space_between_windows_dur,
       'window_to_compare' : window_to_compare_dur,
       'sfui_errorKeys' : ['space_between_windows', 'window_to_compare'],
       'sfui_errorTemplate': "change {{space_between_windows}} to a duration longer than or equal to {{window_to_compare}} (or change {{window_to_compare}})"}
    def g(x):
        return period_summaries(stream, window_to_compare=window_to_compare_dur,
                                space_between_windows=space_between_windows_dur,
                                num_windows=num_windows,
                                num_stddev=x,
                                discard_historical_outliers=discard_historical_outliers)

    summary = stream.mean(over=window_to_compare_dur)
    fb = g(-1 * fire_num_stddev)
    cb = g(-1 * clear_num_stddev)
    ct = g(clear_num_stddev)
    ft = g(fire_num_stddev)
    annotations = [annotate(summary, 'rolling mean', {'sfui_streamType': 'signal'}),
                   annotate(fb, 'lower fire threshold', {'sfui_streamType': 'threshold',
                                                         'sfui_state':'fire',
                                                         'sfui_orientation':'below',
                                                         'sfui_trigger':'outside',
                                                         'influencedBy': 'fire_num_stddev'}),
                   annotate(ft, 'upper fire threshold', {'sfui_streamType': 'threshold',
                                                         'sfui_state':'fire',
                                                         'sfui_orientation':'above',
                                                         'sfui_trigger':'outside' ,
                                                         'influencedBy': 'fire_num_stddev'}),
                   annotate(cb, 'lower clear threshold',
                            {'sfui_streamType': 'threshold',
                             'sfui_state':'clear',
                             'sfui_orientation':'below',
                             'sfui_trigger':'outside' ,
                             'influencedBy': 'clear_num_stddev'}),
                   annotate(ct, 'upper clear threshold',
                            {'sfui_streamType': 'threshold',
                             'sfui_state':'clear',
                             'sfui_orientation':'above',
                             'sfui_trigger':'outside' ,
                             'influencedBy': 'clear_num_stddev'})]
    event_annotations = {'current_window': str(window_to_compare_dur)}
    return detector_helper(summary, fb, cb, ct, ft, orientation, annotations, event_annotations)

# examples
# some_data = data('jvm.cpu.load').mean()
# detector_mean_std(some_data, orientation='out_of_band').publish('mstd_OOB')
# detector_growth_rate(some_data, orientation='above').publish('growth_above')

# These functions create detectors which are insensitive to missing values and irregular arrival
# patterns. The key insight is that, since percentile calculations do not involve nulls,
# "A > 7 for 80% of 10 minutes" is equivalent to
# "the 10-minute 20th percentile of A is greater than 7."
#
# Additionally count transform and percentage above threshold functions are provided.
#
# @author joe


def true_stream(stream, threshold_1, threshold_2, orientation):
    if orientation == 'above':
        return (1 if stream > threshold_1 else None)
    elif orientation == 'below':
        return (1 if stream < threshold_1 else None)
    elif orientation == 'within_range':
        return (1 if stream > threshold_1 and stream < threshold_2 else None)
    elif orientation == 'out_of_band':
        return (1 if stream < threshold_1 or stream > threshold_2 else None)


def denominator_stream(stream, threshold_1, threshold_2, orientation):
    if orientation == 'above' or orientation == 'below':
        return (1 if stream is not None and threshold_1 is not None else None)
    elif orientation == 'within_range':
        return (1 if stream is not None and threshold_1 is not None and threshold_2 is not None else None)
    elif orientation == 'out_of_band':
        either_threshold = (1 if threshold_1 is not None or threshold_2 is not None else None)
        return (1 if stream is not None and either_threshold is not None else None)


def generic_condition(stream, threshold_1, threshold_2, orientation, lasting, mode):
    # Args:
    #       stream (stream): data stream
    #       threshold_1 (number or data stream):
    #       threshold_2
    #       orientation (string): one of 'above', 'below'
    #       lasting (lasting):
    #       mode (string): one of 'observed', 'expected'
    true_count = true_stream(stream, threshold_1, threshold_2, orientation).count(over=lasting.duration)
    denominator = denominator_stream(stream, threshold_1, threshold_2, orientation)
    if mode == 'observed':
        total_count = denominator.count(over=lasting.duration)
    elif mode == 'expected':
        total_count = denominator.size(over=lasting.duration)
    return when((true_count / total_count) > lasting.at_least)


def generic_detector(stream, threshold_1, threshold_2, orientation, observed_lasting,
                            expected_lasting=None, event_annotations=None):
    # Args:
    #       stream (stream): data stream
    #       threshold_1 (number or data stream):
    #       threshold_2
    #       orientation (string): one of 'above', 'below'
    #       observed_lasting (lasting):
    #       expected_lasting (lasting): (optional, default=None)
    #       event_annotations (dict): (optional, default=None)
    # Returns:
    #       detect block
    # denominator = denominator_stream(stream, threshold_1, threshold_2, orientation)
    # observed_true = true_count(stream, threshold_1, threshold_2, orientation, observed_lasting.duration)
    # observed_total = denominator.count(over=observed_lasting.duration)
    # observed_condition = count_condition(observed_true, observed_total, observed_lasting.at_least)
    if expected_lasting is None:
        # return detect(observed_condition, event_annotations=event_annotations)
        return detect(generic_condition(stream, threshold_1, threshold_2, orientation, observed_lasting,
                                        mode='observed'), event_annotations=event_annotations)
    else:
        # expected_true = true_count(stream, threshold_1, threshold_2, orientation, expected_lasting.duration)
        # expected_total = denominator.size(over=expected_lasting.duration)
        # expected_condition = count_condition(expected_true, expected_total, expected_lasting.at_least)
        return detect(generic_condition(stream, threshold_1, threshold_2, orientation, observed_lasting,
                                        mode='observed') and generic_condition(stream, threshold_1, threshold_2,
                                                                               orientation, expected_lasting,
                                                                               mode='expected'),
                      event_annotations=event_annotations)


def above_or_below_detector(stream, threshold, orientation, observed_lasting,
                            expected_lasting=None, event_annotations=None):
    # fires when (stream > (or <) threshold is true in observed_lasting.duration) / (observed data points in
    #    observed.duration) is larger than observed_lasting.at least, and (stream > (or <) threshold is
    #    true in expected_lasting.duration) / (expected data points in expected_lasting.duration)
    #    is larger than expected_lasting.at_least
    # Args:
    #       stream (stream): data stream
    #       threshold (number or data stream):
    #       orientation (string): one of 'above', 'below'
    #       observed_lasting (lasting):
    #       expected_lasting (lasting): (optional, default=None)
    #       event_annotations (dict): (optional, default=None)
    # Returns:
    #       detect block
    return generic_detector(stream, threshold, None, orientation, observed_lasting,
                            expected_lasting=expected_lasting, event_annotations=event_annotations)
    #
    # denominator = denominator_stream(stream, threshold, None, orientation)
    # observed_true = true_count(stream, threshold, None, orientation, observed_lasting.duration)
    # observed_total = denominator.count(over=observed_lasting.duration)
    # observed_condition = count_condition(observed_true, observed_total, observed_lasting.at_least)
    # if expected_lasting is None:
    #     return detect(observed_condition, event_annotations=event_annotations)
    # else:
    #     expected_true = true_count(stream, threshold, None, orientation, expected_lasting.duration)
    #     expected_total = denominator.size(over=expected_lasting.duration)
    #     expected_condition = count_condition(expected_true, expected_total, expected_lasting.at_least)
    #     return detect(observed_condition and expected_condition, event_annotations=event_annotations)


def range_detector(stream, lower_threshold, upper_threshold, orientation, observed_lasting,
                            expected_lasting=None, event_annotations=None):
    # fires when (R is true in observed_lasting.duration) / (observed data points in
    #    observed.duration) is larger than observed_lasting.at least, and (RR is
    #    true in expected_lasting.duration) / (expected data points in expected_lasting.duration)
    #    is larger than expected_lasting.at_least
    #       stream (stream): data stream
    #       lower_threshold (number or data stream):
    #       upper_threshold (number or data stream):
    #       orientation (string): one of 'within_range', 'out_of_band'
    #       observed_lasting (lasting):
    #       expected_lasting (lasting): (optional, default=None)
    #       event_annotations (dict): (optional, default=None)
    # Returns:
    #       detect block
    return generic_detector(stream, lower_threshold, upper_threshold, orientation, observed_lasting,
                            expected_lasting=expected_lasting, event_annotations=event_annotations)
    # denominator = denominator_stream(stream, lower_threshold, upper_threshold, orientation)
    # observed_true = true_count(stream, lower_threshold, upper_threshold, orientation, observed_lasting.duration)
    # observed_total = denominator.count(over=observed_lasting.duration)
    # observed_condition = count_condition(observed_true, observed_total, observed_lasting.at_least)
    # if expected_lasting is None:
    #     return detect(observed_condition, event_annotations=event_annotations)
    # else:
    #     expected_true = true_count(stream, lower_threshold, upper_threshold, orientation, expected_lasting.duration)
    #     expected_total = denominator.size(over=expected_lasting.duration)
    #     expected_condition = when(expected_true, expected_total, expected_lasting.at_least)
    #     return detect(observed_condition and expected_condition, event_annotations=event_annotations)




def compare_streams_ignoring_nulls(stream1, stream2, lasting):
    # returns a stream for which a positive value corresponds to the condition
    #    "stream1 > stream2 for lasting",
    #    ignoring missing values
    # works around the problem of detectors not firing due to one missed point;
    #    leads to better detectors for aperiodic data
    return (stream1 - stream2).percentile(100 * (1.0 - lasting.at_least), over=lasting.duration)


def one_sided_detector(stream1, stream2, lasting):
    # detects when "stream1 > stream2 for lasting", ignoring missing values
    return detect(when(compare_streams_ignoring_nulls(stream1, stream2, lasting) > 0))


def generic_one_sided_detector_with_clear(fire_stream1, fire_stream2, fire_lasting, clear_stream1,
                                          clear_stream2, clear_lasting):
    # detects when "fire_stream1 > fire_stream2 for fire_lasting",
    # clears when "clear_stream1 > clear_stream2 for clear_lasting",
    # both ignoring missing values
    return detect(
        when(compare_streams_ignoring_nulls(fire_stream1, fire_stream2, fire_lasting) > 0),
        when(compare_streams_ignoring_nulls(clear_stream1, clear_stream2, clear_lasting) > 0))


def one_sided_detector_with_clear(stream, fire_threshold, fire_lasting, clear_threshold,
                                  clear_lasting):
    # fires when "stream > fire_threshold for fire_lasting",
    # clears when "stream < clear_threshold for clear_lasting",
    # both ignoring missing values
    return generic_one_sided_detector_with_clear(stream, fire_threshold, fire_lasting,
                                                 clear_threshold, stream, clear_lasting)


def indicator(s, t):
    # equals 1 when s > t, -1 when s < t, null when s = t
    return (s - t) / (s - t).abs()


def two_sided_detector(stream, upper_stream, lower_stream, lasting):
    # detects when "stream > upper_stream OR stream < lower_stream for lasting",
    # ignoring missing values
    upper_indicator = indicator(stream, upper_stream)
    lower_indicator = indicator(lower_stream, stream)
    either_indicator = upper_indicator + lower_indicator  # 2 if both conditions, 0 if one, -2 if neither
    return one_sided_detector(either_indicator, -1, lasting)


def two_sided_detector_with_clear(stream, fire_upper_stream, fire_lower_stream, fire_lasting,
                                  clear_upper_stream, clear_lower_stream, clear_lasting):
    # detects when "stream > fire_upper_stream OR stream < fire_lower_stream for fire_lasting",
    # clears when "stream < clear_upper_stream AND stream > clear_lower_stream for clear_lasting",
    # ignoring missing values
    fire_indicator = indicator(stream, fire_upper_stream) + indicator(fire_lower_stream,
                                                                      stream)  # 2 if both conditions, 0 if one, -2 if neither
    clear_indicator = indicator(clear_upper_stream, stream) + indicator(stream,
                                                                        clear_lower_stream)  # 2 if both conditions, 0 if one, -2 if neither
    return generic_one_sided_detector_with_clear(fire_indicator, -1, fire_lasting, clear_indicator,
                                                 1, clear_lasting)


# utility for visualization of lasting conditions
def percentage_above_threshold(stream, threshold, duration):
    good_count = stream.above(threshold).count(over=duration)
    total_count = stream.count(over=duration)
    return good_count / total_count
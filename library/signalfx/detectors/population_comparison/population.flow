# The main function transforms a stream, assumed to specify a population of interest, into
# a detector which fires when a member of the population becomes an outlier.
#
# The basic toggles are:
#   strategy (mean + standard deviations, or median + median absolute deviations),
#   the number of deviations (determining the sensitivity of the detector),
#   and the orientation (above, below, or out-of-band).
#
# By default the firing and clearing thresholds are different (to reduce flappiness).
# One can also associate lasting objects with the firing and clearing thresholds (by default,
#   both are "100% of 5 minutes").
# Grouping the population is also supported.
#
# @author joe

from signalfx.detectors.aperiodic import aperiodic


def median_MAD_threshold(population_stream, group_by_property=None, num_MAD=1):
    population_median = population_stream.median(by=group_by_property)
    population_MAD = (population_stream.promote(group_by_property) - population_median).abs().median(by=group_by_property)
    return population_median + num_MAD * population_MAD


def detector(population_stream,
             group_by_property=None,
             fire_num_dev=3, fire_lasting=lasting('5m', 1.0),
             clear_num_dev=2.5, clear_lasting=lasting('5m', 1.0),
             strategy='median_MAD', orientation='above', denominator_mode='expected'):
    # Args:
    #     population_stream: data stream specifying a population of emitters
    #     group_by_property (optional, default=None): attribute by which to group population members
    #         before calculating; default behavior (None) is that all members belong to one group
    #     fire_num_dev (number): number of standard deviations above mean required to fire
    #           (optional, default=3)
    #     fire_lasting (lasting): lasting object associated with fire threshold
    #           (optional, default=lasting('5m', 1.0))
    #     clear_num_dev (number): number of standard deviations above mean required to clear,
    #         should have clear_num_stddev <= fire_num_stddev (optional, default=2.5)
    #     clear_lasting (lasting): lasting object associated with clear threshold
    #           (optional, default=lasting('5m', 1.0))
    #     strategy (string): represents method for defining threshold (mean+stddev or median+MAD),
    #           (optional, default='median_MAD', one of 'mean_stddev', 'median_MAD')
    #     orientation (string): specifies whether detect fires when signal is above, below, or
    #           or out-of-band (optional, default='above', one of 'above', 'below', 'out_of_band')
    #     denominator_mode (string): specifies whether to apply lasting conditions to expected
    #           or observed data points (optional, default='expected', one of 'expected', 'observed')
    #
    # Returns:
    #     detect block that fires when a member of the population is at least fire_num_dev
    #         standard/median absolute deviations above the population mean/median
    #         (for parameters specified by fire_lasting) and
    #      clears when that member is no more than clear_num_stddev standard/median absolute
    #         deviations above the population mean/median (for parameters specified by clear_lasting)
    assert fire_num_dev >= clear_num_dev, {'fire_num_dev' : fire_num_dev, 'clear_num_dev' : clear_num_dev,
       'sfui_errorKeys' : ['fire_num_dev', 'clear_num_dev'],
       'sfui_errorTemplate': "{{{fire_num_dev}}} must be greater than or equal to {{{clear_num_dev}}}."}
    def t(x):
        if strategy == 'mean_stddev':
            return population_stream.mean_plus_stddev(stddevs=x, by=group_by_property)
        elif strategy == 'median_MAD':
            return median_MAD_threshold(population_stream,
                                        group_by_property=group_by_property,
                                        num_MAD=x)

    fire_top = t(fire_num_dev)
    clear_top = t(clear_num_dev)
    clear_bot = t(-1 * clear_num_dev)
    fire_bot = t(-1 * fire_num_dev)
    promoted_population_stream = population_stream.promote(group_by_property)
    annotations = [annotate(promoted_population_stream, 'population stream', {'sfui_streamType': 'signal'}),
                   annotate(fire_top, 'upper fire threshold', {'sfui_streamType': 'threshold',
                                                               'sfui_state':'fire',
                                                               'sfui_orientation':'above',
                                                               'sfui_trigger':'outside' ,
                                                               'influencedBy': 'fire_num_dev'}),
                   annotate(fire_bot, 'lower fire threshold', {'sfui_streamType': 'threshold',
                                                               'sfui_state':'fire',
                                                               'sfui_orientation':'below',
                                                               'sfui_trigger':'outside',
                                                               'influencedBy': 'fire_num_dev'}),
                   annotate(clear_bot, 'lower clear threshold',
                            {'sfui_streamType': 'threshold',
                             'sfui_state':'clear',
                             'sfui_orientation':'below',
                             'sfui_trigger':'outside' ,
                             'influencedBy': 'clear_num_dev'}),
                   annotate(clear_top, 'upper clear threshold',
                            {'sfui_streamType': 'threshold',
                             'sfui_state':'clear',
                             'sfui_orientation':'above',
                             'sfui_trigger':'outside' ,
                             'influencedBy': 'clear_num_dev'})]
    if denominator_mode == 'expected':
        if orientation == 'above':
            return detect(when(promoted_population_stream > fire_top, fire_lasting),
                          when(promoted_population_stream < clear_top, clear_lasting),
                          mode='paired',
                          annotations=annotations)
        elif orientation == 'below':
            return detect(when(promoted_population_stream < fire_bot, fire_lasting),
                          when(promoted_population_stream > clear_bot, clear_lasting),
                          mode='paired',
                          annotations=annotations)
        elif orientation == 'out_of_band':
            return detect(
                when(promoted_population_stream > fire_top or promoted_population_stream < fire_bot, fire_lasting),
                when(promoted_population_stream < clear_top and promoted_population_stream > clear_bot, clear_lasting),
                mode='paired',
                annotations=annotations)
    elif denominator_mode == 'observed':
        return aperiodic.generic_detector_with_clear(promoted_population_stream, fire_bot, fire_top, orientation,
                                fire_lasting, clear_bot, clear_top, aperiodic.opposite_orientation(orientation),
                                clear_lasting, fire_expected_lasting=None, clear_expected_lasting=None,
                                mode='split', annotations=annotations, event_annotations=None)


def detector_growth_rate(population_stream,
                         group_by_property=None,
                         fire_growth_rate_threshold=0.2,
                         fire_lasting=lasting('5m', 1.0),
                         clear_growth_rate_threshold=0.1, clear_lasting=lasting('5m', 1.0),
                         strategy='median', orientation='above', denominator_mode='expected'):
    # Args:
    #     population_stream: data stream specifying a population of emitters
    #     group_by_property (optional, default=None): attribute by which to group population members
    #         before calculating; default behavior (None) is that all members belong to one group
    #     fire_growth_rate_threshold (number):
    #     fire_lasting (lasting): lasting object associated with fire threshold
    #           (optional, default=lasting('5m', 1.0))
    #     clear_growth_rate_threshold (number):
    #     clear_lasting (lasting): lasting object associated with clear threshold
    #           (optional, default=lasting('5m', 1.0))
    #     strategy (string): represents method for defining baseline (mean or median),
    #           (optional, default='median', one of 'mean', 'median')
    #     orientation (string): specifies whether detect fires when signal is above, below, or
    #           or out-of-band (optional, default='above', one of 'above', 'below', 'out_of_band')
    #     denominator_mode (string): specifies whether to apply lasting conditions to expected
    #           or observed data points (optional, default='expected', one of 'expected', 'observed')
    #
    # Returns:
    #     detect block that fires when a member of the population is at least fire_growth_rate_threshold
    #           more than the population mean/median (for parameters specified by fire_lasting) and
    #      clears when that member is no more than clear_growth_rate_threshold
    #            above the population mean/median (for parameters specified by clear_lasting)
    assert fire_growth_rate_threshold >= clear_growth_rate_threshold, {
        'fire_growth_rate_threshold': fire_growth_rate_threshold,
        'clear_growth_rate_threshold': clear_growth_rate_threshold,
        'sfui_errorKeys': ['fire_growth_rate_threshold', 'clear_growth_rate_threshold'],
        'sfui_errorTemplate': "{{{fire_growth_rate_threshold}}} must be greater than or equal to {{{clear_growth_rate_threshold}}}."}
    def t(x):
        if strategy == 'mean':
            return population_stream.mean_plus_stddev(stddevs=0, by=group_by_property) * (1 + x)
        elif strategy == 'median':
            return median_MAD_threshold(population_stream,
                                        group_by_property=group_by_property,
                                        num_MAD=0) * (1 + x)

    fire_top = t(fire_growth_rate_threshold)
    clear_top = t(clear_growth_rate_threshold)
    clear_bot = t(-1 * clear_growth_rate_threshold)
    fire_bot = t(-1 * fire_growth_rate_threshold)
    promoted_population_stream = population_stream.promote(group_by_property)
    annotations = [annotate(promoted_population_stream, 'population stream', {'sfui_streamType': 'signal'}),
                   annotate(fire_top, 'upper fire threshold', {'sfui_streamType': 'threshold',
                                                               'sfui_state':'fire',
                                                               'sfui_orientation':'above',
                                                               'sfui_trigger':'outside' ,
                                                               'influencedBy': 'fire_growth_rate_threshold'}),
                   annotate(fire_bot, 'lower fire threshold', {'sfui_streamType': 'threshold',
                                                               'sfui_state':'fire',
                                                               'sfui_orientation':'below',
                                                               'sfui_trigger':'outside',
                                                               'influencedBy': 'fire_growth_rate_threshold'}),
                   annotate(clear_bot, 'lower clear threshold',
                            {'sfui_streamType': 'threshold',
                             'sfui_state':'clear',
                             'sfui_orientation':'below',
                             'sfui_trigger':'outside' ,
                             'influencedBy': 'clear_growth_rate_threshold'}),
                   annotate(clear_top, 'upper clear threshold',
                            {'sfui_streamType': 'threshold',
                             'sfui_state':'clear',
                             'sfui_orientation':'above',
                             'sfui_trigger':'outside' ,
                             'influencedBy': 'clear_growth_rate_threshold'})]
    if denominator_mode == 'expected':
        if orientation == 'above':
            return detect(when(promoted_population_stream > fire_top, fire_lasting),
                          when(promoted_population_stream < clear_top, clear_lasting),
                          mode='split',
                          annotations=annotations)
        elif orientation == 'below':
            return detect(when(promoted_population_stream < fire_bot, fire_lasting),
                          when(promoted_population_stream > clear_bot, clear_lasting),
                          mode='split',
                          annotations=annotations)
        elif orientation == 'out_of_band':
            return detect(
                when(promoted_population_stream > fire_top or promoted_population_stream < fire_bot, fire_lasting),
                when(promoted_population_stream < clear_top and promoted_population_stream > clear_bot, clear_lasting),
                mode='split',
                annotations=annotations)
    elif denominator_mode == 'observed':
        return aperiodic.generic_detector_with_clear(promoted_population_stream, fire_bot, fire_top, orientation,
                                fire_lasting, clear_bot, clear_top, aperiodic.opposite_orientation(orientation),
                                clear_lasting, fire_expected_lasting=None, clear_expected_lasting=None,
                                mode='split', annotations=annotations, event_annotations=None)


# examples
# some_data = data('jvm.cpu.load')
# detector(some_data, strategy='median_MAD', orientation='out_of_band').publish('MAD_OOB')
# detector(some_data, fire_num_dev=0.5, clear_num_dev=0.2, orientation='below').publish('mstd_below')
# detector(some_data, group_by_property=['aws_instance_type'],
#    fire_num_dev=2, clear_num_dev=1, orientation='below').publish('mstd_below')

# These functions transform a stream, assumed to specify a population of interest, into
# thresholds for detecting outliers; and facilitate the creation of detectors which fire when
# a member of the population becomes an outlier.
#
# The basic toggles are:
#   strategy (mean + standard deviations, or median + median absolute deviations),
#   the number of deviations (determining the sensitivity of the detector),
#   and the orientation (above, below, or out-of-band).
#
# By default the firing and clearing thresholds are different (to reduce flappiness).
# One can also associate lasting objects with the firing and clearing thresholds (by default,
#   both are "100% of 5 minutes").
#
# @author joe


mean_string = 'mean_stddev'
median_string = 'median_MAD'

def mean_stddev_threshold(population_stream, group_by_property=None, num_stddev=1):
    return population_stream.mean(by=group_by_property) + num_stddev * population_stream.stddev(by=group_by_property)


def median_MAD_threshold(population_stream, group_by_property=None, num_MAD=1):
    population_median = population_stream.median(by=group_by_property)
    population_MAD = (population_stream - population_median).abs().median(by=group_by_property)
    return population_median + num_MAD * population_MAD

def threshold(population_stream, group_by_property=None, num_dev=1, strategy=mean_string):
    if strategy == mean_string:
        return mean_stddev_threshold(population_stream,
                                     group_by_property=group_by_property,
                                     num_stddev=num_dev)
    else:
        if strategy == median_string:
            return median_MAD_threshold(population_stream,
                                        group_by_property=group_by_property,
                                        num_MAD=num_dev)

def above_detector(population_stream,
                group_by_property=None,
                fire_num_dev=3, fire_lasting=lasting('5m', 1.0),
                clear_num_dev=2.5, clear_lasting=lasting('5m', 1.0),
                strategy=mean_string):
    # Args:
    #     population_stream: data stream specifying a population of emitters
    #     group_by_property (optional, default=None): attribute by which to group population members
    #         before calculating; default behavior (None) is that all members belong to one group
    #     fire_num_stddev (number): number of standard deviations above mean required to fire
    #           (optional, default=3)
    #     fire_lasting (lasting): lasting object associated with fire threshold
    #           (optional, default=lasting('5m', 1.0))
    #     clear_num_stddev (number): number of standard deviations above mean required to clear,
    #         should have clear_num_stddev <= fire_num_stddev (optional, default=2.5)
    #     clear_lasting (lasting): lasting object associated with clear threshold
    #           (optional, default=lasting('5m', 1.0))
    #     strategy (string): represents method for defining threshold (mean+stddev or median+MAD)
    #
    # Returns:
    #     detect block that fires when a member of the population is at least fire_num_stddev standard
    #         deviations above the population mean (for parameters specified by fire_lasting) and clears
    #         when that member is no more than clear_num_stddev standard deviations above the
    #         poplation mean (for parameters specified by clear_lasting)
    fire_threshold = threshold(population_stream,
                               group_by_property=group_by_property,
                               num_dev=fire_num_dev,
                               strategy=strategy)
    clear_threshold = threshold(population_stream,
                                group_by_property=group_by_property,
                                num_dev=clear_num_dev,
                                strategy=strategy)
    return detect(when(population_stream > fire_threshold, fire_lasting),
                      when(population_stream < clear_threshold, clear_lasting))

def below_detector(population_stream,
                group_by_property=None,
                fire_num_dev=3, fire_lasting=lasting('5m', 1.0),
                clear_num_dev=2.5, clear_lasting=lasting('5m', 1.0),
                strategy=mean_string):
    # Args:
    #     population_stream: data stream specifying a population of emitters
    #     group_by_property (optional, default=None): attribute by which to group population members
    #         before calculating; default behavior (None) is that all members belong to one group
    #     fire_num_stddev (number): number of standard deviations below mean required to fire
    #           (optional, default=3)
    #     fire_lasting (lasting): lasting object associated with fire threshold
    #           (optional, default=lasting('5m', 1.0))
    #     clear_num_stddev (number): number of standard deviations below mean required to clear,
    #         should have clear_num_stddev <= fire_num_stddev (optional, default=2.5)
    #     clear_lasting (lasting): lasting object associated with clear threshold
    #           (optional, default=lasting('5m', 1.0))
    #
    # Returns:
    #     detect block that fires when a member of the population is at least fire_num_stddev standard
    #         deviations below the population mean (for parameters specified by fire_lasting) and clears
    #         when that member is no fewer than clear_num_stddev standard deviations below the
    #         poplation mean (for parameters specified by clear_lasting)
    fire_threshold = threshold(population_stream,
                               group_by_property=group_by_property,
                               num_dev=-1 * fire_num_dev,
                               strategy=strategy)
    clear_threshold = threshold(population_stream,
                                group_by_property=group_by_property,
                                num_dev=-1 * clear_num_dev,
                                strategy=strategy)
    return detect(when(population_stream < fire_threshold, fire_lasting),
                  when(population_stream > clear_threshold, clear_lasting))


def out_of_band_detector(population_stream,
                group_by_property=None,
                fire_num_dev=3, fire_lasting=lasting('5m', 1.0),
                clear_num_dev=2.5, clear_lasting=lasting('5m', 1.0),
                strategy=mean_string):
    # Args:
    #     population_stream: data stream specifying a population of emitters
    #     group_by_property (optional, default=None): attribute by which to group population members
    #         before calculating; default behavior (None) is that all members belong to one group
    #     fire_num_stddev (number): number of standard deviations away from mean required to fire
    #           (optional, default=3)
    #     fire_lasting (lasting): lasting object associated with fire threshold
    #           (optional, default=lasting('5m', 1.0))
    #     clear_num_stddev (number): number of standard deviations away from mean required to clear,
    #         should have clear_num_stddev <= fire_num_stddev (optional, default=2.5)
    #     clear_lasting (lasting): lasting object associated with clear threshold
    #           (optional, default=lasting('5m', 1.0))
    #
    # Returns:
    #     detect block that fires when a member of the population goes out-of-band
    #       (for parameters specified by fire_lasting), clears when that member is back in-band
    #       ((for parameters specified by clear_lasting)
    fire_top_threshold = threshold(population_stream,
                                   group_by_property=group_by_property,
                                   num_dev=fire_num_dev,
                                   strategy=strategy)
    fire_bottom_threshold = threshold(population_stream,
                                      group_by_property=group_by_property,
                                      num_dev=-1 * fire_num_dev,
                                      strategy=strategy)
    clear_top_threshold = threshold(population_stream,
                                    group_by_property=group_by_property,
                                    num_dev=clear_num_dev,
                                    strategy=strategy)
    clear_bottom_threshold = threshold(population_stream,
                                    group_by_property=group_by_property,
                                    num_dev=-1 * clear_num_dev,
                                    strategy=strategy)
    return detect(when(population_stream > fire_top_threshold or population_stream < fire_bottom_threshold, fire_lasting),
                  when(population_stream < clear_top_threshold and population_stream > clear_bottom_threshold, clear_lasting))


#examples
#above_detector(data('jvm.cpu.load'),
#               group_by_property='aws_instance_type',
#               strategy=mean_string).publish('too_high')

#below_detector(data('jvm.cpu.load'),
#               fire_num_dev=1.5, fire_lasting=None,
#               clear_num_dev=1.0,
#               strategy=median_string).publish('not_high_enough')


# These functions transform a stream, assumed to be either decreasing or increasing, into an
# estimate of how long it will take (in hours) for the stream to reach 0 (in case decreasing),
# or some user-specified capacity (in case increasing); and facilitate the creation of a
# detector based on how many hours of capacity are left.
#
# @author joe

def hours_left_stream(stream, increment_size=duration('1m'), imputed_value=None):
    # Args:
    #     stream: data stream, assumed to be decreasing and non-negative
    #     *increment_size deprecated but still part of signature; previously
    #           used to estimate rate of change
    #     imputed_value: if a number is provided, use this value when stream.rateofchange() > 0;
    #           otherwise output stream will be null in this case (default=None)
    #
    # Returns:
    #     hours left until stream has value 0, calculated via linear extrapolation; null if stream
    #     is increasing
    if imputed_value is None:
        return (stream / (-3600 * stream.rateofchange().below(0)))
    else:
        return (stream / (-3600 * stream.rateofchange().below(0))) if stream.rateofchange() < 0 else imputed_value


def hours_left_stream_incr(stream, maximum_capacity, increment_size=duration('1m'), imputed_value=None):
    # Args:
    #     stream: data stream, assumed to be increasing
    #     maximum_capacity (number): value at which stream is exhausted,
    #         e.g. 100 for disk.summary_utilization
    #     increment_size (duration): interval length used to estimate rate of change
    #         (optional, default=duration('1m'))
    #
    # Returns:
    #     hours left until stream has value maximum_capacity, calculated via linear extrapolation;
    #         is optimistic in that it uses the maximum hours left over the estimation_period
    return hours_left_stream(maximum_capacity - stream, increment_size=increment_size, imputed_value=imputed_value)


def hours_left_stream_detector(stream, minimum_value=0, lower_threshold=24, fire_lasting=lasting('10m', 1.0),
                               clear_threshold=36, clear_lasting=lasting('10m', 1.0),
                               increment_size=duration('1m')):
    # Args:
    #     stream: data stream, assumed to be decreasing
    #     minimum_value (number): value at which stream is considered empty (optional, default=0)
    #     lower_threshold (number):  threshold for firing (number of hours) (optional, default=24)
    #     fire_lasting (lasting): lasting object associated with lower_threshold;
    #         note the estimation_period serves as a quasi-duration argument
    #         (optional, default=lasting('10m', 1.0))
    #     clear_threshold (number): threshold for clearing (number of hours) (optional, default=36);
    #         using a clear_threshold larger than lower_threshold should reduce flappiness
    #     clear_lasting (lasting): lasting object associated with clear threshold (optional,
    #         default=lasting('10m', 1.0))
    #     increment_size (duration): interval length used to estimate rate of change
    #         (optional, default=duration('1m'))
    # Returns:
    #     detect block which fires when stream is estimated to "run out" (i.e., have value 0) within
    #         lower_threshold hours (for fire_lasting); clears when stream is estimated not to be
    #         exhausted for at least clear_threshold hours (for clear_lasting)
    hours_left = hours_left_stream(stream - minimum_value, increment_size=increment_size, imputed_value=clear_threshold + 1)
    lower_threshold_signal = const(lower_threshold)
    clear_threshold_signal = const(clear_threshold)
    annotations = [annotate(hours_left, 'hours left', {'sfui_streamType': 'signal', 'influencedBy':
        'increment_size'}),
        annotate(lower_threshold_signal, 'lower fire threshold', {'sfui_streamType': 'threshold',
                                                                  'sfui_state':'fire',
                                                                  'sfui_orientation':'below',
                                                                  'sfui_trigger':'outside'}),
        annotate(clear_threshold_signal, 'lower fire threshold', {'sfui_streamType': 'threshold',
                                                                  'sfui_state':'clear',
                                                                  'sfui_orientation':'below',
                                                                  'sfui_trigger':'outside'})
        ]
    return detect(when(hours_left < lower_threshold_signal, fire_lasting),
                  when(hours_left > clear_threshold_signal, clear_lasting),
                  annotations=annotations)


def hours_left_stream_incr_detector(stream, maximum_capacity, lower_threshold=24,
                                    fire_lasting=lasting('10m', 1.0),
                                    clear_threshold=36, clear_lasting=lasting('10m', 1.0),
                                    increment_size=duration('1m')):
    # Args:
    #     stream: data stream, assumed to be increasing
    #     maximum_capacity (number): value at which stream is exhausted,
    #         e.g. 100 for disk.summary_utilization
    #     lower_threshold (number):  threshold for firing (number of hours) (optional, default=24)
    #     fire_lasting (lasting): lasting object associated with lower_threshold;
    #         note the estimation_period serves as a quasi-duration argument
    #         (optional, default=lasting('10m', 1.0))
    #     clear_threshold (number): threshold for clearing (number of hours) (optional, default=36);
    #         using a clear_threshold larger than lower_threshold should reduce flappiness
    #     clear_lasting (lasting): lasting object associated with clear threshold (optional,
    #         default=lasting('10m', 1.0))
    #     increment_size (duration): interval length used to estimate rate of change
    #         (optional, default=duration('1m'))
    # Returns:
    #     detect block which fires when stream is estimated to "run out" (i.e., hit
    #         maximum_capacity) within lower_threshold hours (for fire_lasting);
    #         clears when stream is estimated to have at least clear_threshold hours left
    #         (for clear_lasting)
    return hours_left_stream_detector(maximum_capacity - stream,
                                      lower_threshold=lower_threshold, fire_lasting=fire_lasting,
                                      clear_threshold=clear_threshold,
                                      clear_lasting=clear_lasting,
                                      increment_size=increment_size)

# examples
# hours_left_stream(100 - data('disk.summary_utilization')).publish('b')


# hours_left_stream_detector(100 - data('disk.summary_utilization'),
#                            fire_lasting=lasting('5m', 1.0)).publish('a')


# hours_left_stream_detector(100 - data('disk.summary_utilization'),
#                            clear_threshold=36, clear_lasting=lasting('5m', 0.95)).publish('c')


# hours_left_stream_incr_detector(data('disk.summary_utilization'),
#                            100, clear_threshold=48).publish('d')
